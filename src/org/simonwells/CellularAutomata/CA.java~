package org.simonwells.CellularAutomata;

import java.io.IOException;
import java.util.Enumeration;
import java.util.ListIterator;
import java.util.Vector;

import org.simonwells.CellularAutomata.Cell;
import org.simonwells.CellularAutomata.Pattern;

/**
* Encapsulates a generation of Cells
*
* @author Simon Wells <siwells@gmail.com>
* @version 1.0
* @since 1.6
*/
public class CA
{
/*	public static void main(String[] args)
	{
		CA ca =	new CA();	
		ca.init();
		ca.printInfo();
		ca.loop();
	}*/
	
	/**
	* Zero Argument Constructor.
	*
	* Initialises the member variables for the CellularAutomata and the flags that control how the CA should be calculated and displayed
	*/
	public CA()
	{
		this.consoleOutput = true;
		this.infiniteloop = false;
		this.symbolicOutput = true;
		this.wraparound = true;
		this.numGenerations = 10;
		this.width = 100;
		this.generation = new Vector();
		this.pattern = new Pattern();
		this.pattern.setPattern("01101010");
	}
	
	/** 
  * Given a parent generation caluclate the child generation.
  *
  * @param parent describing the state of the parent generation.
  * @return Return a Vector containing the next generation of the CA.
  */
	public Vector breed(Vector parent)
	{
		boolean left=false, middle=false, right=false;
		Cell leftCell, middleCell, rightCell;
		Vector childGeneration = new Vector();
		
		// Iterate through the current generation. Use a for loop to do so as for each cell we are also looking at
		// the cells that are both ahead of and behind the current cell during each iteration. Iterators would make
		// for more complicated code
		for(int i=0; i < parent.size(); ++i)
		{
			middleCell = (Cell) parent.get(i);
			middle = middleCell.isAlive();
			
			// Determine state of left neighbour cell. Get the previous cell and check its state
			// Boundary condition: If generation wrapsaround and we are at the start of the generation then
			// get the state of the rightmost cell. If not wrapping around then set cell to dead (e.g. doesn't exist).			
			if(i == 0)
			{
				if(wraparound)
				{
					leftCell = (Cell) parent.get(parent.size()-1);
					left = leftCell.isAlive();	
				}
				else
					left = false;
			}
			else
			{
				leftCell = (Cell) parent.get(i-1);
				left = leftCell.isAlive();
			}
			
			// Determine state of right neighbour cell. Get the next cell and check its state
			// Boundary condition: If generation wrapsaround and we are at the end of the generation then
			// get the state of the leftmost cell. If not wrapping around then set cell to dead (e.g. doesn't exist).
			if(i < parent.size()-1)
			{
				rightCell = (Cell) parent.get(i+1);
				right = rightCell.isAlive();
			}
			else
			{
				if(wraparound)
				{
					rightCell = (Cell) parent.get(0);
					right = rightCell.isAlive();
				}
				else
					right = false;
			}
			
			// Once we have the state of cell plus left and right neighbours, create a cell cluster object and
			// get the approprate child from that cluster according to the pattern for this CA.
			CellCluster tmpCluster = new CellCluster(left, middle, right);
			Cell childCell = tmpCluster.getChild(this.pattern);
			
			childGeneration.add(i, childCell);
		}
		return childGeneration;
	}
	
	/** 
  * Controls the flow of execution: (1) breed next generation, then (2) display next generation
  */
	public void generateAutomata()
	{
		// Note: For efficieny we store a single generation that is the current state of the CA. This means
		// that we have to display the generation each time it is generated hence the mingling of computation
		// and display code.
		this.generation = this.breed(this.generation);
		this.printGeneration(this.generation.elements());
	}
	
	/**  Initialise the seed generation.  */
	public void init()
	{
		for (int i = 0; i < width; ++i)
		{
			if(i == 50)
				this.generation.add(new Cell(true));
			this.generation.add(new Cell(false));
		}
	}
	
	/** 
  * Control the looping behaviour of the program so that we can calculate a fixed number of generation or otherwise loop indefinitely.
  */
	public void loop()
	{
		// The seed is also the first generation so display it
		this.printGeneration(this.generation.elements());
		
		if(this.infiniteloop)
		{
			for (;;)
			{
				this.generateAutomata();
			}
		}
		else
		{
			for(int idx = 0; idx < this.numGenerations; ++idx)
			{
				this.generateAutomata();
			}
		}
		
	}
	
	/** Display the current generation on the console. Console output is only representative and behaviour could be platform specific. If you want to work with the generated CA then you should output to a file or database (but it does produce pretty patterns ).
  *
  * @param e An enumeration encapsulating the CA generation to display.
  */
	public void displayOnConsole(Enumeration e)
	{
		while(e.hasMoreElements())
		{
			Cell tmp = (Cell) e.nextElement();
			if (this.symbolicOutput)
				System.out.print( tmp.isAlive() ? '\u25A0' : '\u00A0' );
			else
				System.out.print( tmp.isAlive() ? "1" : "0" );
		}	
		System.out.print("\n");	
	}
	
	/** Print the current generation.  
	*
	*Various output methods are available such as (1) console output, (2) file output, (3) database output. 
	*
	* @param e (Required) An enumeration of Cells
	*/
	public void printGeneration(Enumeration e)
	{
		if(this.consoleOutput)
			displayOnConsole(e);
	}
	
	/** 
  * Display a header describing the CA {@link Pattern} and initial seed Generation.
  */
	public void printInfo()
	{
		//System.out.println("\033c");
		System.out.println("Pattern: \n"+this.pattern.toString());
		// Display the seed generation
		System.out.println("Seed: ");
		this.displayOnConsole(this.generation.elements());
		System.out.println(" ");
	}
	
	private boolean symbolicOutput;
	private boolean consoleOutput;
	private boolean infiniteloop;
	private boolean wraparound;
	private int numGenerations;
	private int width;
	private Vector generation;
	private Pattern pattern;
}
